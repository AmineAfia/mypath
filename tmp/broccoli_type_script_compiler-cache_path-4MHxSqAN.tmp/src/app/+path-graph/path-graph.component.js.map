{"version":3,"file":"path-graph.component.js","sourceRoot":"","sources":["path-graph.component.ts"],"names":[],"mappings":"AAAA,gEAAgE;AAChE,kCAAkC;AAClC,oCAAoC;AACpC,uEAAuE;AAEvE,eAAe;AACf,yBAAyB;AACzB,gCAAgC;AAChC,8CAA8C;AAC9C,4CAA4C;AAC5C,KAAK;AACL,oCAAoC;AAEpC,mDAAmD;AAEnD,iBAAiB;AACjB,gBAAgB;AAChB,mBAAmB;AACnB,kBAAkB;AAClB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,kBAAkB;AAClB,kBAAkB;AAClB,qCAAqC;AACrC,OAAO;AACP,mDAAmD;AACnD,0DAA0D;AAC1D,OAAO;AACP,8CAA8C;AAC9C,kDAAkD;AAClD,sDAAsD;AACtD,KAAK;AACL,OAAO;AACP,4DAA4D;AAC5D,OAAO;AACP,yBAAyB;AACzB,yDAAyD;AACzD,iBAAiB;AACjB,oBAAoB;AACpB,oBAAoB;AACpB,qBAAqB;AACrB,qBAAqB;AACrB,KAAK;AACL,OAAO;AACP,2EAA2E;AAC3E,2EAA2E;AAC3E,OAAO;AACP,2BAA2B;AAC3B,+DAA+D;AAC/D,qFAAqF;AACrF,2EAA2E;AAC3E,yDAAyD;AACzD,4DAA4D;AAC5D,KAAK;AACL,OAAO;AACP,0EAA0E;AAC1E,OAAO;AACP,8BAA8B;AAC9B,uBAAuB;AACvB,sCAAsC;AACtC,qEAAqE;AACrE,uEAAuE;AACvE,gBAAgB;AAChB,sFAAsF;AACtF,KAAK;AACL,OAAO;AACP,qEAAqE;AACrE,8CAA8C;AAC9C,OAAO;AACP,+BAA+B;AAC/B,iDAAiD;AACjD,2DAA2D;AAC3D,qBAAqB;AACrB,wBAAwB;AACxB,4BAA4B;AAC5B,0DAA0D;AAC1D,sBAAsB;AACtB,KAAK;AACL,OAAO;AACP,8EAA8E;AAC9E,+EAA+E;AAC/E,OAAO;AACP,+BAA+B;AAC/B,iDAAiD;AACjD,mBAAmB;AACnB,qBAAqB;AACrB,wBAAwB;AACxB,4BAA4B;AAC5B,qBAAqB;AACrB,mBAAmB;AACnB,sCAAsC;AACtC,KAAK;AACL,OAAO;AACP,sEAAsE;AACtE,mDAAmD;AACnD,OAAO;AACP,+BAA+B;AAC/B,8BAA8B;AAC9B,yGAAyG;AACzG,yCAAyC;AACzC,KAAK;AACL,OAAO;AACP,mEAAmE;AACnE,0EAA0E;AAC1E,oCAAoC;AACpC,OAAO;AACP,8BAA8B;AAC9B,wCAAwC;AACxC,iEAAiE;AACjE,4CAA4C;AAC5C,2BAA2B;AAC3B,wBAAwB;AACxB,0BAA0B;AAC1B,sCAAsC;AACtC,4BAA4B;AAC5B,oCAAoC;AACpC,oBAAoB;AACpB,qCAAqC;AACrC,+CAA+C;AAC/C,OAAO;AACP,KAAK;AAEL,IAAI","sourcesContent":["// import { Component, Input, ElementRef } from '@angular/core';\n// import * as D3 from 'd3/index';\n// import * as Moment from 'moment';\n// import { PathGraphConfComponent } from './path-graph-conf.component'\n\n// @Component({\n//   moduleId: module.id,\n//   selector: 'app-path-graph',\n//   templateUrl: 'path-graph.component.html',\n//   styleUrls: ['path-graph.component.css']\n// })\n// export class PathGraphComponent {\n    \n//  @Input() config: Array<PathGraphConfComponent>;\n\n//  private host;\n//  private svg;\n//  private margin;\n//  private width;\n//  private height;\n//  private xScale;\n//  private yScale;\n//  private xAxis;\n//  private yAxis;\n//  private htmlElement: HTMLElement;\n//  /**\n//  * We request angular for the element reference \n//  * and then we create a D3 Wrapper for our host element\n//  **/\n//  constructor(private element: ElementRef) {\n//  this.htmlElement = this.element.nativeElement;\n//  this.host = D3.select(this.element.nativeElement);\n//  }\n//  /**\n//  * Everythime the @Input is updated, we rebuild the chart\n//  **/\n//  ngOnChanges(): void {\n//  if (!this.config || this.config.length === 0) return;\n//  this.setup();\n//  this.buildSVG();\n//  this.populate();\n//  this.drawXAxis();\n//  this.drawYAxis();\n//  }\n//  /**\n//  * Basically we get the dom element size and build the container configs\n//  * also we create the xScale and yScale ranges depending on calculations\n//  **/\n//  private setup(): void {\n//  this.margin = { top: 20, right: 20, bottom: 40, left: 40 };\n//  this.width = this.htmlElement.clientWidth - this.margin.left - this.margin.right;\n//  this.height = this.width * 0.5  - this.margin.top - this.margin.bottom;\n//  this.xScale = D3.time.scale().range([0, this.width]);\n//  this.yScale = D3.scale.linear().range([this.height, 0]);\n//  }\n//  /**\n//  * We can now build our SVG element using the configurations we created\n//  **/\n//  private buildSVG(): void {\n//  this.host.html('');\n//  this.svg = this.host.append('svg')\n//  .attr('width', this.width + this.margin.left + this.margin.right)\n//  .attr('height', this.height + this.margin.top + this.margin.bottom)\n//  .append('g')\n//  .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n//  }\n//  /**\n//  * Method to create the X Axis, will use Month as tick date format\n//  * Also assing some classes for CSS Stylimg\n//  **/\n//  private drawXAxis(): void {\n//  this.xAxis = D3.svg.axis().scale(this.xScale)\n//  .tickFormat(t => Moment(t).format('MMM').toUpperCase())\n//  .tickPadding(15);\n//  this.svg.append('g')\n//  .attr('class', 'x axis')\n//  .attr('transform', 'translate(0,' + this.height + ')')\n//  .call(this.xAxis);\n//  }\n//  /**\n//  * Method to create the Y Axis, will use numeric values as tick date format\n//  * Also assing some classes for CSS Stylimg and rotating the axis vertically\n//  **/\n//  private drawYAxis(): void {\n//  this.yAxis = D3.svg.axis().scale(this.yScale)\n//  .orient('left')\n//  .tickPadding(10);\n//  this.svg.append('g')\n//  .attr('class', 'y axis')\n//  .call(this.yAxis)\n//  .append('text')\n//  .attr('transform', 'rotate(-90)');\n//  }\n//  /**\n//  * Will return the maximum value in any dataset inserted, so we use\n//  * it later for the maximum number in the Y Axis\n//  **/\n//  private getMaxY(): number {\n//  let maxValuesOfAreas = [];\n//  this.config.forEach(data => maxValuesOfAreas.push(Math.max.apply(Math, data.dataset.map(d => d.y))));\n//  return Math.max(...maxValuesOfAreas);\n//  }\n//  /**\n//  * Now we populate using our dataset, mapping the x and y values\n//  * into the x and y domains, also we set the interpolation so we decide\n//  * how the Area Chart is plotted.\n//  **/\n//  private populate(): void {\n//  this.config.forEach((area: any) => {\n//  this.xScale.domain(D3.extent(area.dataset, (d: any) => d.x));\n//  this.yScale.domain([0, this.getMaxY()]);\n//  this.svg.append('path')\n//  .datum(area.dataset)\n//  .attr('class', 'area')\n//  .style('fill', area.settings.fill)\n//  .attr('d', D3.svg.area()\n//  .x((d: any) => this.xScale(d.x))\n//  .y0(this.height)\n//  .y1((d: any) => this.yScale(d.y))\n//  .interpolate(area.settings.interpolation));\n//  });\n//  }\n\n// }\n"]}